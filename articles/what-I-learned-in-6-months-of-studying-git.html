<!DOCTYPE html>
<html>

<head>
    <title>tagarela</title>
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <!-- Setting base allows articles (inside the article subfolder) to re-use the "about" sidebar, which is one level above -->
    <base href="../" />
    <link rel="stylesheet" type="text/css" href="style.css" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js" type="text/javascript"></script>
    <script src="scripts/load-about.js" type="text/javascript"></script>
</head>

<body class="mainBody">
    <div id="about" class="sidebar"></div>
    <div class="content">
        <div class="article">
            <h2 id="title">What I learned in 6 months of studying Git</h2>
            <p>
                Git is the hottest version control system out there. Its wide adoption masks its youth: born in the
                early 2000s, Git is borderline millennial.
                When Git came around, I was an elementary school student. Not surprisingly, years before I ever got my
                hands on my first programming language, developers around the world set on particular ways of using Git.
            </p>
            <p>
                The extensive set of tools that Git provides is flexible, complex and unintuitive. Many of us arrived
                late to the party and had to quickly adapt to the rhythm on the dance floor. While version control is
                critical to software development, the daily job of the majority of developers is not to understand Git,
                or to use it efficiently, but to write robust, maintainable code. For that reason, they learn a small
                set of commands and stick to it.
            </p>
            <p>
                Learning about the inner workings of Git and how to leverage its powerful toolset has been a fruitful
                investment to me. Merge conflicts are no longer scary and interactive rebases are my new favorite thing.
                In this article, I will share my workflow and the improvements I made to it over time. Git experts be
                warned: the content below might aggravate you.
            </p>
            <h3>Integration Branch</h3>
            <p>
                What is an <em>integration branch</em>? I borrowed the term from
                <a href="https://www.pluralsight.com/authors/paolo-perrotta">Paolo Perrotta</a>. It refers to the main
                branch where development happens, frequently called "master". "Integration" describes well the goal of
                the branch while being generic enough to outlive naming conventions, so I'll use it here.
            </p>
            <p class="aside">
                I highly recommend Perrotta's Git courses on Pluralsight. As a visual learner, the animations helped me
                understand the concepts faster. Plus, Perrotta has a great sense of humor.
            </p>
            <p>
                For all professional projects I worked on, committing directly to the integration branch was prohibited.
                I could preach about the benefits of feature/topic branches, but that is beside the point of this post.
                The relevant information is that I never, ever, commit to the integration branch.
            </p>
            <p>
                As any other human being, I hate merge conflicts. I update my feature branches often to avoid any big,
                nasty conflicts. Here's how I used to do it: I would start by checking out the integration branch, then
                pulling from it. After that, I would checkout my feature branch and merge the integration branch
                into it.
            </p>
            <p>
                I am a particularly lazy developer that tries to save as many keystrokes as possible. If I can
                automatize a process, I will. Thinking myself clever, I wrote a PowerShell function to run the update
                commands for me:
            </p>
            <div class="code">
                <code>
                    git checkout integration<br/>
                    git pull<br/>
                    git checkout feature-branch<br/>
                    git merge integration<br/>
                </code>
            </div>
            <p>
                While talking about Git, one of my coworkers pointed out the existence of <em>remote tracking
                    branches</em>. These are special local branches that strictly follow remotes, cannot be committed to
                and are synchronized during fetch. Using them directly for merge/rebase greatly simplifies the process:
            </p>
            <div class="code">
                <code>
                    git fetch<br/>
                    git merge origin/integration<br/>
                </code>
            </div>
            <p>
                No need for a fancy PowerShell function! No need for my own integration branch!
            </p>
            <p class="aside">
                At that time, I knew very little about Git, learning only what I needed to be productive. It never
                occurred to me that the information about the remote and the its branches was available locally. I
                thought that to merge from remote branches, I had to sync my working copy with them. I did
                not know what pull was doing. I did not know when to use fetch by itself. As much as it seems obvious to
                me now, I'm sure I'm not the only one using Git inefficiently because I don't understand it. If you are
                on the same boat as past-me, check out the answer to
                <a
                    href="https://stackoverflow.com/questions/55731891/effects-of-git-remote-update-origin-prune-on-local-changes">
                    this Stack Overflow question</a>.
            </p>
            <h3>Creating a New Branch</h3>
            <p>
                There is a second characteristic of mine (besides laziness) that pushes me towards automation: I
                misspell things all the time. My team has some guidance around branch naming. Each contributor should
                prefix their branches with "users/&lt;contributor-username&gt;". I lost count of how many times I wrote
                "users" wrong. Or my own name wrong! That's why I created another PowerShell function to create
                feature branches for me. It does everything I need: fetches origin for the latest changes at the
                integration branch and creates/checks out the new feature branch with the prefix in place:
            </p>
            <div class="code">
                <code>
                    function New-Feature-Branch {<br/>
                        param([string] $name)<br/>
                        git fetch --prune --all<br/>
                        # The --no-track option is necessary since the default is to track the start point<br/>
                        git checkout -b "&lt;prefix&gt;/$name" --no-track origin/integration<br/>
                    }<br/>
                </code>
            </div>
            <p>
                This function could be further generalized to accept a base branch and a prefix, if I ever need it. For
                now, all of my work is done on top of origin/integration and my prefix is always the same. Less
                parameters means less keystrokes, so I never bothered to do that extra work. That is the beauty of
                writing your own helper functions: they don't need to fit anyone else's needs!
            </p>
            <h3>Interactive Rebases and Force Pushing</h3>
            <p>
                When I started using Git, I did not bother learning about rewriting history. I read many opinionated
                articles that said rewriting history was terrible; it was the worst thing you could do, and you should
                be ashamed of lying to your coworkers. Another tidbit about me is that I do not trust computers. I
                cannot rest easy knowing my work in progress is sitting on a single machine. I am fully prepared for my
                computer to blow up overnight, any night. As backups move to the cloud, I tend to push to cloud remotes
                often, too often. My commits are sometimes tiny and silly. "Fix word spelling", "Add a null check",
                "Delete a forgotten empty line".
            </p>
            <p>
                If I were to merge my feature branches into integration as they naturally are, my co-workers would hate
                me. My commits would flood our history. I'm not being dramatic, there is such a thing as committing too
                often, and learning to rewrite history changed my life. I can think of the story I want to tell and hide
                all paranoid commits. There is, however, a catch. Since I push too early and too frequently,
                the history of my feature branches is not limited to me. It is shared between my local copy of the
                repository and the main copy on the cloud. If I rewrite history, I can no longer push (without force).
            </p>
            <p>
                The internet is loud and clear: you should never rewrite shared history. This is good advice: rewriting
                history can be destructive and may break your coworkers (who may never forgive you). While rewriting the
                history of my feature branches on the cloud is definitely considered rewriting history, no one except
                for me should be working on these branches, so I allow myself to be audacious and force push.
            </p>
            <p>
                Yes, you read that right. I rewrite shared history.
            </p>
            <p>
                I am fully aware that I am playing with fire. At least, I use --force-with-lease instead of plain old
                --force, which means Git checks to see if there is no commit I haven't fetched that would be lost. For
                now, that has never been the case. I always use the same computer for development, and I never start
                working before fetching, so it is highly unlikely for --force-with-lease to fail. If my workflow changed
                (say, I got another computer, or got over my fear of losing progress) I would need to be more careful
                about force pushing.
            </p>
            <p class="aside">
                Disclaimer: I do not recommend you to follow me into the pits of Git's dangerous commands.
            </p>
            <h3>Conclusion</h3>
            <p>
                The more I learn about Git, the more I see how worthwhile it is to understand the tools I use in my
                day to day job. Humans make mistakes and learning how to recover from them (and how to avoid them in the
                future) is critically important to avoid losing hard work.
            </p>
        </div>
    </div>
</body>

</html>